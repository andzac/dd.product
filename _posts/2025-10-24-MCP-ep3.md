---
title: 'MCP Series Episode 3: Securing the Connection'
date: 2025-10-24
permalink: /posts/2025/10/MCP-ep3
tags:
  - MCP
  - AI
  - en-US
---

## Introduction

Dear reader, welcome back!

>This is episode 3 of the MCP series. If you missed the last episode, you can find them all [here](https://andzac.github.io/dd.product/year-archive/).

In the previous episode, we defined the actors and the JSON-RPC messages.

Now, we'll build the infrastructure to transport and secure those messages.

## The Transport Layer: How Clients and Servers Talk

A JSON-RPC message needs a reliable 'bridge' to travel between client and server. This bridge must be persistent and bidirectional. It should allow the server to quickly send notifications back to the client.

> Every JSON-RPC message MUST be UTF-8 encoded

A technology that many developers are familiar with for this exact purpose is the WebSocket. A simple client-side WebSocket looks like this:

```javascript
// Create WebSocket connection.
const socket = new WebSocket("ws://localhost:8080");

// Connection opened
socket.addEventListener("open", (event) => {
  socket.send("Hello Server!");
});

// Listen for messages
socket.addEventListener("message", (event) => {
  console.log("Message from server ", event.data);
});
```

SDKs that implement the MCP protocol already handle messaging for you. This lets us focus on the key features of the MCP server or client we want to create, as shown in the [Typescript SDK](https://github.com/modelcontextprotocol/typescript-sdk).

```javascript
// Set up Express and HTTP transport
const app = express();

app.use(express.json());

app.post('/mcp', async (req, res) => {
    // Create a new transport for each request to prevent request ID collisions
    const transport = new StreamableHTTPServerTransport({
        sessionIdGenerator: undefined,
        enableJsonResponse: true
    });

    res.on('close', () => {
        transport.close();
    });

    await server.connect(transport);
    await transport.handleRequest(req, res, req.body);

});

```

As partially spotted by the snippet above, MCP (that is `transport agnostic`) supports two standard transport mechanisms that have to be declared when initializing the communication:

1. **STDIO**

2. **Streamable HTTP** (that replaces the HTTP+SSE transport from protocol version 2024-11-05.)

We'll briefly introduce both of them, with an ad hoc episode dedicated to the security aspect to consider in the protocol choice.

> It is also possible to create a custom transport mechanism, and it is up to the producer of such a transport protocol to make sure that the message format and message lifecycle are not modified.

### STDIO

With this mechanism, the client simply runs the server as a subprocess; then, the client receives messages through `stdin` and writes the output message using `stdout`.

Neither the client nor the server can write on their stream any message that is not a valid MCP message.

The server may write UTF-8 strings to its standard error (`stderr`) for logging purposes. Clients MAY capture, forward, or ignore this logging.

### Streamable HTTP

This solution is the way to go if a server may establish multiple client connections. In this way, the MCP server can be deployed somewhere, and by providing an endpoint URL (i.e., `https://your-service.com/mcp`) is possible to communicate with a client using the HTTP methods `GET` and `POST`.

## Authorization mechanism when communicating

Before establishing the communication between the client and the server is necessary to verify that the client is authorized (on behalf of the user) to send/receive messages with one or more server implementations.

The verification process (client authentication and authorization) may change depending on the protocol mechanism established:

- On Streamable HTTP, the client is not exposing a long-life API key, instead follow the *OAUth 2.x Client Credential Flow*

- On STDIO is possible to define the API key as an environment variable that can be consumed at runtime

### OAUth 2.x Client Credential Flow

The authentication/authorization process is defined in two distinct phases.

#### Phase 1: Acquiring the Bearer Token

- The client obtains the bearer token by making a `POST` request to the Authorization Server's token endpoint (i.e., `https://my-server.com/mcp/oauth/token`), providing as request body the `grant_type`, `client_id`, and `client_secret`.

```bash
curl -X POST 'https://auth.your-service.com/oauth/token' \
-H 'Content-Type: application/x-www-form-urlencoded' \
-d 'grant_type=client_credentials' \
-d 'client_id=your-client-id' \
-d 'client_secret=your-client-secret'
```

- The Authorization server replies with a JSON that contains the bearer token.

```JSON
{
  "access_token": "eyJhbGciOiJSUzI1NiIsInR...",
  "token_type": "Bearer",
  "expires_in": 3600
}
```

#### Phase 2: Connecting to the MCP Server

The client, now in possession of the Bearer Token, can make authenticated requests to the Streamable HTTP endpoint. It must include this token in the Authorization header for every request it makes.

- The client sends a standard HTTP POST request to the server's endpoint, containing the JSON-RPC message

```bash
# First, store your token from Phase 1 in a variable
TOKEN="eyJhbGciOiJSUzI1NiIsInR..."

# Make an MCP POST request to the Streamable HTTP endpoint
curl -X POST 'https://your-service.com/mcp' \
-H "Content-Type: application/json" \
-H "Authorization: Bearer $TOKEN" \
-d '{
  "jsonrpc": "2.0",
  "id": 123,
  "method": "prompts/list"
}'
```

- Server validates the request, replying with two possible HTTP status codes

    a. If the token is valid, the MCP Server will respond with a `HTTP/1.1 200` OK returning back the list as JSON Object.

    b. If the token is invalid or missing, the server will reject the handshake with a standard `HTTP/1.1 401` Unauthorized response, and the connection will not be upgraded.

For those who are eager to get their hands dirty, I suggest getting your hand dirty following [this tutorial](https://medium.com/@aparna_prasad/build-your-first-mcp-server-in-typescript-with-code-02af89ef2a5f) or also [this nice training](https://huggingface.co/learn/mcp-course/en/unit1/communication-protocol?utm_source=chatgpt.com).

If you prefer a watch, so I'll learn better, I watched [this YouTube](https://www.youtube.com/watch?v=kQmXtrmQ5Zg) workshop that I want to recommend.

For those who prefer a bit more of a lagging approach, they can wait till the next episode, where we'll start to design an MCP server that will be used in the next episodes.

Stay tuned and see you soon!

A.

## References

- <https://modelcontextprotocol.io/specification/2025-06-18/basic/transports>
- <https://developer.mozilla.org/en-US/docs/Web/API/WebSocket>
- <https://github.com/modelcontextprotocol/typescript-sdk>

---
&copy; 2025 Andrea Zaccaro. All rights reserved.
